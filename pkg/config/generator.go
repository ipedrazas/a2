package config

import (
	"bytes"
	"fmt"

	"gopkg.in/yaml.v3"
)

// GeneratorOptions contains the options for generating a config file.
type GeneratorOptions struct {
	Profile   string   // Application profile (cli, api, library, desktop)
	Target    string   // Maturity target (poc, production)
	Languages []string // Explicit languages to check
	Files     []string // Required files
	Coverage  float64  // Coverage threshold (0 means use default)
}

// generatedConfig is a minimal representation for YAML output.
// We use a separate struct to only output non-empty fields.
type generatedConfig struct {
	Language  *generatedLanguage `yaml:"language,omitempty"`
	Files     *generatedFiles    `yaml:"files,omitempty"`
	Coverage  *generatedCoverage `yaml:"coverage,omitempty"`
	Execution *generatedExec     `yaml:"execution,omitempty"`
}

type generatedLanguage struct {
	Explicit []string `yaml:"explicit,omitempty"`
}

type generatedFiles struct {
	Required []string `yaml:"required,omitempty"`
}

type generatedCoverage struct {
	Threshold float64 `yaml:"threshold,omitempty"`
}

type generatedExec struct {
	Parallel bool `yaml:"parallel,omitempty"`
}

// Generate creates a Config from the given options.
func Generate(opts GeneratorOptions) *Config {
	cfg := DefaultConfig()

	// Set explicit languages if provided
	if len(opts.Languages) > 0 {
		cfg.Language.Explicit = opts.Languages
	}

	// Set required files if provided
	if len(opts.Files) > 0 {
		cfg.Files.Required = opts.Files
	}

	// Set coverage threshold if provided (non-zero)
	if opts.Coverage > 0 {
		cfg.Coverage.Threshold = opts.Coverage
	}

	return cfg
}

// ToYAML converts a Config to YAML bytes.
// It only outputs non-default values to keep the YAML minimal.
func ToYAML(cfg *Config, opts GeneratorOptions) ([]byte, error) {
	gen := &generatedConfig{}

	// Only include explicit languages if set
	if len(cfg.Language.Explicit) > 0 {
		gen.Language = &generatedLanguage{
			Explicit: cfg.Language.Explicit,
		}
	}

	// Only include files if different from default
	defaultFiles := []string{"README.md", "LICENSE"}
	if !stringSliceEqual(cfg.Files.Required, defaultFiles) {
		gen.Files = &generatedFiles{
			Required: cfg.Files.Required,
		}
	}

	// Only include coverage if different from default (80)
	if cfg.Coverage.Threshold != 80.0 {
		gen.Coverage = &generatedCoverage{
			Threshold: cfg.Coverage.Threshold,
		}
	}

	var buf bytes.Buffer

	// Add header comment with profile and target info
	buf.WriteString("# A2 Configuration\n")
	buf.WriteString("# Generated by: a2 add\n")
	if opts.Profile != "" {
		fmt.Fprintf(&buf, "# Profile: %s\n", opts.Profile)
	}
	if opts.Target != "" {
		fmt.Fprintf(&buf, "# Target: %s\n", opts.Target)
	}
	buf.WriteString("#\n")
	buf.WriteString("# Run checks with: a2 check")
	if opts.Profile != "" {
		fmt.Fprintf(&buf, " --profile %s", opts.Profile)
	}
	if opts.Target != "" {
		fmt.Fprintf(&buf, " --target %s", opts.Target)
	}
	buf.WriteString("\n\n")

	// Marshal the config
	yamlData, err := yaml.Marshal(gen)
	if err != nil {
		return nil, err
	}

	// If everything is default, add a comment
	if string(yamlData) == "{}\n" {
		buf.WriteString("# Using all default settings\n")
		buf.WriteString("# Uncomment and modify as needed:\n")
		buf.WriteString("#\n")
		buf.WriteString("# language:\n")
		buf.WriteString("#   explicit: [go]  # Override auto-detection\n")
		buf.WriteString("#\n")
		buf.WriteString("# files:\n")
		buf.WriteString("#   required:\n")
		buf.WriteString("#     - README.md\n")
		buf.WriteString("#     - LICENSE\n")
		buf.WriteString("#\n")
		buf.WriteString("# coverage:\n")
		buf.WriteString("#   threshold: 80\n")
		buf.WriteString("#\n")
		buf.WriteString("# checks:\n")
		buf.WriteString("#   disabled:\n")
		buf.WriteString("#     - go:coverage\n")
	} else {
		buf.Write(yamlData)
	}

	return buf.Bytes(), nil
}

// stringSliceEqual checks if two string slices are equal.
func stringSliceEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}
